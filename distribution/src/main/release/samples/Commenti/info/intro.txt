In questo folder "samples" ci sono tutti gli esempi forniti da CXF.

Ogni progetto su cui ho fatto prove/ho studiato ha un file "leggime.txt"

====================  Argomenti importanti:  ===============================

Inizializzazione Spring =>wsdl_first/Spring-bean-setup.txt  


=============		wsdl_first    ==================
Come , a partire da un wsdl, costruire server e client , Spring e non spring based, con diversi transports.

Server:Non Spring jetty transport   [-Pserver]         usa javax.xml.ws.Endpoint.publish(implementor)
	   Spring  jetty                [-Pserver-spring]  usa server-applicationContext.xml
	   Non Spring netty             [-Pserver-netty]
	   Tomcat 7                     [tomcat7:run]
	   
	   
Client:Non Spring standard transport    [-Pclient]
	   Non Spring netty                 [-Pclient-netty]
	   Spring jetty standard transport  [-Pclient-spring]



=============		java_first_jaxws    ==================
Come , a partire da una interfaccia SIE demo.hw.server.HelloWorld.java, costruire server e client .
Nessuna classe e' generata da generate-sources!!


Server:Non Spring jetty transport   [-Pserver]
	   Tomcat 7                     [tomcat7:run]  http://localhost:9000/java_first_jaxws/services/hello_world?wsdl
	   
	   
Client:Non Spring standard transport    [-Pclient] 
Il client non usa wsdl, justo la SEI compilata HelloWorld.class per capire come generare il SOAP.






=============		jax_rs_basic  [output = xml]  ==================
Implementa un endpoint demo.jaxrs.server.CustomerService.java   annotato jax-rs 2.0  [@Path,@Produces] lanciato con JAXRSServerFactoryBean.
L'esempio implementa jax-rs sub-resource-locator [vedi http://localhost:9000/customerservice/orders/223/products/323]
Client usa apache http-client 
Ambo client e server non sono configurati con Spring.



Server:[-Pserver]   No war!!Non gira in Tomcat. Server lanciato usando JAXRSServerFactoryBean

Client:[-Pclient]   Usa httpclient per generare le requests.


=============		jax_rs_spring_security    ==================
Jax-rs server che gira su tomcat7 e jetty configurato con Spring <jaxrs:server> con  metodi annotati jax-rs ed esposti 
con basic-auth configurata sia con @Secured [spring-security-core] che con <security:global-method-security> in beans.xml
Server gira sy jetty e tomcat7:run.

Ogni request ha assegnato un header "Authorization" con valore "Basic " + base64Encode(name + ":" + password)
Lato server user/pwd sono associati ad un role in beans.xml.
Ogni metodo e' autorizzato per uno o piu ruoli o in beans.xml con <global-method-security > oppure nell' SEI interface con annotazioni CustomerServiceSecured.


Output e' appliction/xml


Server:[-Pserver]   

Client:[-Pclient] Usa httpclient per generare le requests.




=============		jax_rs_basic_https    ==================
Implementa un server  annotato jax-rs 2.0  [@Path,@Produces] lanciato con JAXRSServerFactoryBean ma con Spring configration
ServerConfig.xml configura keyManagers,trustManagers,port del transport jetty con tags <httpj:engine-factory> e <httpj:engine> imponendo l autenticazione del client certificate

Client usa org.apache.cxf.jaxrs.client.WebClient.java [cxf-rt-rs-client] configurando con ClientConfig.xml con tag <http:conduit> il keystore da usare.

Server:[-Pserver]  Lanciato come JAXRSServerFactoryBean, configurato con   <httpj:engine-factory > in ServerConfig.xml

Client:[-Pclient]   org.apache.cxf.jaxrs.client.WebClient configurato con ClientConfig.xml 

Consente di scegliere client authentication, quale certificato usare serverside, quali certificati client autorizzare,etc



=============	java_first_jms	    ==================
SOAP over JMS usando ActiveMQ senza usare configurazione Spring.
A partire da interfaccia java annotatata JAX-WS demo.service.HelloWorld, genera hello.wsdl .
Per partire dal, wsdl vedi jms_spring_config.

java2ws:[-Pserver]
Genera il wsdl hello.wsdl a partire da SEI  demo.service.HelloWorld


Server:[-Pserver]   
Lancia ActiveMQ in ascolto su tcp  61616 
JaxWsServerFactoryBean e' usato per pubblicare l endpoint HelloWorldImpl.java in ascolto sulla queue :
jms:queue:test.cxf.jmstransport.queue?timeToLive=1000&jndiConnectionFactoryName=ConnectionFactory&jndiInitialContextFactory=org.apache.activemq.jndi.ActiveMQInitialContextFactory&jndiURL=tcp://localhost:61616

Client:[-Pclient]   
JaxWsServerFactoryBean e' usato per creare un proxy client e per inviare il messagio jms alla queue :
jms:queue:test.cxf.jmstransport.queue?timeToLive=1000&jndiConnectionFactoryName=ConnectionFactory&jndiInitialContextFactory=org.apache.activemq.jndi.ActiveMQInitialContextFactory&jndiURL=tcp://localhost:61616


=============	jax_rs_content_negotiation	    ==================
Implementa un server  annotato jax-rs 2.0  [@Path,@Produces] lanciato con JAXRSServerFactoryBean
Nessuna configurazione Spring.


2 profili POM:


[-Pserver]Implementa un endpoint CustomerService  annotato jax-rs 2.0  [@Path,@Produces] lanciato con JAXRSServerFactoryBean 


[-Pclient]Lancia client che usa apache HttpClient per effettuare GETs verso l endpoint settando header "Accept" sia application/xml
che application/json

Solo il type definito in CustomerService [@Produces("")] funziona.Se l'header inviato dal client non matcha quello del @Produces
il server ritorna error 6.



=============	jms_spring_config	    ==================
SOAP over JMS a partire dal WSDL [/jms_spring_config/src/main/config/CustomerService.wsdl] usando Spring configuration
 per client e server.
 Genera interfaccia annotata JAX-WS
 Spring usa <jaxws:client> e <jaxws:endpoint> per configurare WS server e client.
Il server non lancia ActiveMQ, semplicemente si connette ad esso.


[phase generate-sources]legge  jms_spring_config/src/main/config/CustomerService.wsdl
cxf-codegen-plugin e' usato per generare jaxb e SEI interface in target/generated-sources
com.example.customerservice.CustomerService.java

[-Pjms.broker] => lancia ActiveMQ invocando activemq-maven-plugin:run  BrokerMojo.execute() in activemq-maven-plugin-5.8.0.jar
Il broker e' istanza org.apache.activemq.broker.BrokerService.java in activemq-broker-5.12.0.jar
Si puo evitare di lanciare il broker se si lancia activemq installato localmente.

[-Pserver] => esegue polling dei messaggi sulla queue jms:queue:test.queue.
CustomerServiceSpringServer.java usa ClassPathXmlApplicationContext per lanciare  server-applicationContext.xml
I singletons sono nestati:  ActiveMQConnectionFactory => PooledConnectionFactory => ConnectionFactoryFeature => jaxws:endpoint




[-Pclient] =>  invia SOAP over JMS messages verso la queue 
CustomerServiceSpringClient.java usa ClassPathXmlApplicationContext per lanciare client-applicationContext.xml.
I singletons sono nestati:  ActiveMQConnectionFactory => PooledConnectionFactory => jmsConfig =>JMSConfigFeature => ConnectionFactoryFeature => <jaxws:client>
Il client invia header replyDestination per indicare al server dove inviare le risposte.
A quel punto estrae CustomerServiceTester da Spring context che e' iniettato col proxy  <jaxws:client> per invocare i metodi (invio jms payload) dal server.
Il client invia il messaggio con header Reply To=queue://endpoint-out-queue e ascolta x un  certo timeout per il messggio di risposta su tale queue.
Se il timeout scade :java.lang.RuntimeException: Timeout receiving message with correlationId 11f3f0f934794e08931dd87bcd7f2b400000000000000001
	at org.apache.cxf.transport.jms.JMSConduit.sendAndReceiveMessage(JMSConduit.java:236)














 

